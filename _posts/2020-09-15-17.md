---
title: LLVM - 가상화 난독화 (1/2)
date: 2020-09-15
Author: yarncha
categories: [LLVM]
tags: [LLVM]
comments: true
---

이번 주의 목표

-   [x] 가상화 난독화 C 코드 작성해보기
-   [ ] LLVM으로 해당 코드의 IR 확인해보기

* * *

이번 주에는 본격적인 가상화 난독화를 들어가기에 앞서, 나한테 가상화 난독화라는게 아직 낯선 개념이어서 직접 가상화된 난독화 코드를 작성해 보고, 바이너리 코드를 확인해볼 것이다.

# 1. 가상화 난독화 C 코드 작성해보기

난독화를 위해, 다음 코드를 사용했다.

```c
int adder(int a, int b){
  int c;
  c = a+b;
  c = c*100;
  return c;
}
```

해당 코드를 switch문을 이용해 각 줄을 switch문의 case로 나누어 줄 것이다.

난독화해본 코드는 다음과 같다.

```c
//각 연산자를 함수로 빼 둠
int plusOp(int a, int b) {
	return a + b;
}

int mulOp(int a, int b) {
	return a * b;
}

int adderObfuscated(int para01, int para02) {
	int (*func01)(int, int) = plusOp;
	int (*func02)(int, int) = mulOp;
  //포인터 함수 선언

	int res = 0;
  //변수 선언

	for (int i = 0; i >= 0;) {
		switch (i)
		{
		case 0:
      // 난독화 전 : c=a+b;
			para01 = func01(para01, 1);  //dummy
			para01 = func01(para01, para02);
			res = func01(res, para01);
			res = func01(-1, res); //dummy
			i = 2;
			break;
		case 1:
      // 난독화 전 : return c;
			return res;
      // i++;
      // break;
      // 어차피 return하고 끝나서 i 이동시켜 줄 필요도 없고 break;도 필요 없을 것 같은데 넣어두면 좀 더 보기 어려울 것 같기도 하다
		case 2:
      // 난독화 전 : c=c*100;
			res = func02(1, res);  //dummy
			res = func02(res, 100);
			i = 1;
			break;
		}
	}

	return 0;
}
```

일단, 한 줄당 switch문의 case 하나로 쪼개고, i를 이동시키면서 순서대로 실행하도록 했다. 연산자도 미리 함수로 정의해 놓고, 함수 포인터를 통해 연산하는 부분을 수행할 수 있도록 했고, 중간중간에 dummy 코드로 복잡하게 해 보았다.  
또.. 해 보면서 알았던 점인데, switch문에서 변수를 선언할 수 없어서(한다고 해도 해당 case안에서만 사용 가능함) 모든 변수 선언도 함수 선언과 마찬가지로 미리 상단에서 해 두어야 할 것 같다.

더 복잡하게 하려면, i를 읽기 어렵게 하고 순서를 마구 섞어도 좋을 것 같고, dummy 코드를 지금보다 더 넣어도 더 난독화가 될 것 같다. 또 지금은 연산자만 함수로 빼 두었는데 연산자가 아니라 어떤 작업을 하는 코드? 자체를 함수로 빼 두고 실행하면 좋지 않을까 싶다.

# 2. LLVM으로 해당 코드의 IR 확인해보기

작성한 코드를 예전에 코드 프린트용으로 작성해둔 path를 이용해 확인해본다.

난독화 전

![img](\images\17_01.png)

난독화 후

![img](\images\17_02.png)

(plusOp 함수와 mulOp 함수)

![img](\images\17_03.png)
![img](\images\17_04.png)

일단 코드가 엄청나게 길어졌는데, sw.bb라는 BasicBlock이 눈에 띈다. LLVM에서 스위치문은 이렇게 for.body BasicBlock에서 나타나는 것처럼 sw.bb#로 나타나고 어떤 값이면 어떤 case로 갈 것인지 알려주고, 마지막으로 epliog를 실행해서 for.end로 진행하는 것으로 추정된다. (하지만 bb4에서 return이 있어서 갈 일이 없는 BasicBlock 같다.)

(이렇게 난독화하고 보니까 나도 어떤 흐름인지 보기가 힘든데.. 보기 쉽게 cfg로 나타내는 방법이 있었던 것 같기도 한데 찾아봐야겠다!!)

<!-- References -->
